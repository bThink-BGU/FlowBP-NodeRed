const fs = require("fs");
const path = require("path");
const AdapterMessageTypes = {
  RUN: "RUN",
  DEBUG: "DEBUG",
  STEP: "STEP",
  STOP: "STOP"
};

const EngineMessageTypes = {
  STATE: "STATE",
  LOG: "LOG"
};
const Message = function (type, payload) {
  return {
    type: type,
    payload: payload
  }
}

module.exports = function (RED) {
  // see https://github.com/hlapp/node-red-embedded-start/blob/master/index.js for events and
  //   RED2 = require('../../node-red')
  var Convert = require('ansi-to-html');
  var convert = new Convert();
  const equal = require('deep-equal');
  const fs = require('fs');
  const glob = require("glob");
  const path = require('path');
  const net = require('net');
  const util = require("util");
  var debuglength = RED.settings.debugMaxLength || 1000;
  const reconnectTime = RED.settings.socketReconnectTime || 10000;
  const socketTimeout = RED.settings.socketTimeout || null;
  const msgQueueSize = RED.settings.tcpMsgQueueSize || 1000;
  let port = 1234;
  let topic = '';
  let connectionPool = {};
  var count = 0;
  let status;
  // const Denque = require('denque');
  let debug;
  let stream = true;
  let datatype = 'utf8';
  let newline = process.platform === "win32" ? "\r\n" : "\n";
  let closing = false;
  let server;

  /**
   * Enqueue `item` in `queue`
   * @param {Denque} queue - Queue
   * @param {*} item - Item to enqueue
   * @private
   * @returns {Denque} `queue`
   */
  const enqueue = (queue, item) => {
    // drop msgs from front of queue if size is going to be exceeded
    if (queue.length === msgQueueSize) {
      queue.shift();
    }
    queue.push(item);
    return queue;
  };

  /**
   * Shifts item off front of queue
   * @param {Deque} queue - Queue
   * @private
   * @returns {*} Item previously at front of queue
   */
  const dequeue = queue => queue.shift();

  function closeConnections() {
    for (var c in connectionPool) {
      if (connectionPool.hasOwnProperty(c)) {
        connectionPool[c].end();
        connectionPool[c].unref();
      }
    }
  }

  function closeServer() {
    closeConnections();
    closing = true;
    server.close();
    RED.log.info("stopped listening on port " + port);
  }

  function resetNodesState(f) {
    for (let n of f.config.flows) {
      let node = RED.nodes.getNode(n.id);
      if (node) {
        node.context().set('tokens', []);
        node.status("");
      }
    }
  }

  function copyEventDefs(f) {
    let types = f.config.flows.map(obj => obj.type + ".EventDef.js")
    glob.sync("packages/**/*.EventDef.js")
      // .filter(file=>types.includes(path.basename(file)))
      .forEach(file => fs.copyFileSync(file, path.join('engine', 'js', path.basename(file))));
  }

  function writeFlowsToFile(f) {
    let allFlows = JSON.stringify(f); //RED2.nodes.getFlows().flows);
    let flowFileContent = "var model = " + allFlows + "\n";
    // RED.log.info("\n----------JSON-----------------\n" + allFlows + "\n----------JSON-----------------\n");

    (async () => {
      try {
        await glob.sync("engine/**/*.EventDef.js")
          .forEach(file => fs.rmSync(file, { force: true }))
        await fs.rmSync(path.join('engine', 'js', 'report'), { recursive: true, force: true });
        await fs.rmSync(path.join('engine', 'js', 'run-logs'), { recursive: true, force: true });
        await fs.writeFileSync(path.join('engine', 'js', '00-amodel.js'), flowFileContent);
      } catch (error) {
        RED.log.info("error:" + error.message);
      }
    })();
  }

  prc = null;
  function startEngine(f) {
    const spawn = require('child_process').spawn;
    const treeKill = require('tree-kill');


    var exec = process.platform === "win32" ? 'bpjs.bat' : 'bpjs.sh';
    //TODO: replace js with a list of all files
    var files = fs.readdirSync(path.join('engine', 'js')).map(f => path.join('engine', 'js', f));
    var flags = ['--use_sync_priority_ess'];
    var args = flags.concat(files);

    if (prc) {
      treeKill(prc.pid, 'SIGTERM', (err) => {
        if (err) {
          RED.log.info('Failed to terminate engine process:', err);
        } else {
          RED.log.info('Engine process terminated');
        }
      });
    }

    RED.log.info('Starting engine process');
    prc = spawn(path.join('engine', exec), args, { shell: true });

    prc.stdout.setEncoding('utf8');
    prc.stderr.setEncoding('utf8');
    prc.stdout.on('data', function (data) {
      var str = data.toString()
      var lines = str.split(/(\r?\n)/g);
      for (let line of lines)
        sendDebug({ type: EngineMessageTypes.LOG, payload: line });
      //RED.log.info(lines.join(""));
    });

    prc.stderr.on('data', function (data) {
      var str = data.toString()
      var lines = str.split(/(\r?\n)/g);
      for (let line of lines)
        sendDebug({ type: EngineMessageTypes.LOG, payload: line });
      RED.log.info(lines.join(""));
    });

    prc.on('close', function (code) {
      RED.log.info('process exit code ' + code);
      resetNodesState(f);
    });
  }

  function init() {
    debug = RED.nodes.getNode('debug');
    server = net.createServer(function (socket) {
      socket.setKeepAlive(true, 120000);
      if (socketTimeout !== null) {
        socket.setTimeout(socketTimeout);
      }
      var id = (1 + Math.random() * 4294967295).toString(16);
      var fromi;
      var fromp;
      connectionPool[id] = socket;
      count++;
      status = {
        text: count + " connections",
        event: "connect",
        ip: socket.remoteAddress,
        port: socket.remotePort,
        _session: { type: "tcp", id: id }
      };

      var buffer = (datatype == 'buffer') ? Buffer.alloc(0) : "";
      socket.on('data', function (data) {
        if (datatype != 'buffer') {
          data = data.toString(datatype);
        }
        if (stream) {
          var msg;
          if ((typeof data) === "string" && newline !== "") {
            buffer = buffer + data;
            var parts = buffer.split(newline);
            for (var i = 0; i < parts.length - 1; i += 1) {
              // msg = {topic: topic, payload: parts[i], ip: socket.remoteAddress, port: socket.remotePort};
              // msg._session = {type: "tcp", id: id};
              msg = parts[i];
              if (msg !== "")
                receivedFromEngine(msg);
            }
            buffer = parts[parts.length - 1];
          } else {
            // msg = {topic: topic, payload: data, ip: socket.remoteAddress, port: socket.remotePort};
            // msg._session = {type: "tcp", id: id};
            msg = parts[i];
            receivedFromEngine(msg);
          }
        } else {
          if ((typeof data) === "string") {
            buffer = buffer + data;
          } else {
            buffer = Buffer.concat([buffer, data], buffer.length + data.length);
          }
          fromi = socket.remoteAddress;
          fromp = socket.remotePort;
        }
      });
      socket.on('end', function () {
        if (!stream || (datatype === "utf8" && newline !== "") || (datatype === "base64")) {
          if (buffer.length > 0) {
            var msg = { topic: topic, payload: buffer, ip: fromi, port: fromp };
            msg._session = { type: "tcp", id: id };
            receivedFromEngine(JSON.stringify(msg));
          }
          buffer = null;
        }
      });
      socket.on('timeout', function () {
        RED.log.info("timeout closed socket port " + port);
        socket.end();
      });
      socket.on('close', function () {
        delete connectionPool[id];
        count--;
        status = {
          text: count + " connection",
          event: "disconnect",
          ip: socket.remoteAddress,
          port: socket.remotePort,
          _session: { type: "tcp", id: id }

        };
      });
      socket.on('error', function (err) {
        RED.log.info(err);
      });
    });

    server.on('error', function (err) {
      if (err) {
        RED.log.error("unable to listen on port " + port + " error: " + err.toString());
      }
    });

    RED.httpAdmin.post("/debug-operations/step", function (req, res) {
      RED.log.info("Someone clicked on step");
      try {
        sendToEngine(Message(AdapterMessageTypes.STEP, {}));
        res.sendStatus(200);
      } catch (error) {
        res.sendStatus(500);
      }
    });

    RED.events.on('flows:started', function (f) {
      closeConnections();
      writeFlowsToFile(f);
      copyEventDefs(f);
      resetNodesState(f);
      startEngine(f);
    });

    server.listen(port, function (err) {
      if (err) {
        RED.log.error("unable to listen on port " + port + " error: " + err.toString());
      } else {
        RED.log.info("listening on port " + port);
        RED.events.on('flows:ended', function (f) {
          RED.log.info("flows:ended");
          closeServer(RED);
        });
      }
    });
  }

  function stop() {
    closeServer();
  }

  function setNodeStatus(nodeId, text, fillColor, shape = 'dot') {
    let node1 = RED.nodes.getNode(nodeId);
    node1.status({ fill: fillColor, shape: shape, text: text });
    // example: node.status({fill: "grey", shape: "dot", text: "common.status.connecting"});
    // shape can be: ring, dot
    // fill can be: red, green, yellow, blue or grey
    // for more information: https://nodered.org/docs/creating-nodes/status
  }

  function setNodeContext(nodeId, data) {
    let node1 = RED.nodes.getNode(nodeId);
    node1.context().set("messages", data);
    // for more information: https://nodered.org/docs/creating-nodes/context
  }

  function receivedFromEngine(msg) {
    RED.log.info("Received from engine: " + msg);
    let json = JSON.parse(msg);
    if (json.type == EngineMessageTypes.LOG)
      sendDebug(json);
    else if (json.type == EngineMessageTypes.STATE) {
      let n = RED.nodes.getNode(json.payload.id);
      if (n == null) {
        RED.log.error("received status for node [" + json.payload.id + "] but it does not exists");
        return;
      }
      let tokens = n.context().get('tokens') || [];
      if (json.payload.add) {
        tokens.push(json.payload.token);
      } else {
        const index = tokens.findIndex(element => equal(element, json.payload.token));
        if (index > -1) {
          tokens.splice(index, 1);
        } else {
          RED.log.error("context of node [" + json.payload.id + "] is: " + tokens + ", and for some reason does not contain token: " + json.payload.token);
        }
      }
      n.context().set('tokens', tokens);
      setNodeStatus(json.payload.id, "# tokens=" + tokens.length, json.payload.add ? 'green' : 'grey', tokens.length > 0 ? 'dot' : 'ring');
    }
  }

  function sendToEngine(msg) {
    RED.log.info("Sending to engine: " + JSON.stringify(msg));
    // RED.comms.publish("debug", msg);

    if (msg.payload != null) {
      for (var id in connectionPool) {
        let c = connectionPool[id]
        if (Buffer.isBuffer(msg.payload)) {
          c.write(msg.payload);
        } else {
          c.write(Buffer.from(JSON.stringify(msg) + "\n"));
        }
      }
    }
  }

  function sendDebug(message) {
    // don't put blank errors in sidebar (but do add to logs)
    //if ((msg.msg === "") && (msg.hasOwnProperty("level")) && (msg.level === 20)) { return; }
    msg = RED.util.encodeObject(message, { maxLength: debuglength });
    let payload = msg.payload;
    try {
      payload = convert.toHtml(payload);
    } catch (e) {
    }
    if ((typeof payload === 'string' || payload instanceof String) && payload.trim() == "") return;
    RED.events.emit("comms", {
      topic: "debug",
      data: {
        id: "id",
        z: "z",
        _alias: "alias",
        path: "path",
        name: "BPEngine",
        topic: msg.type,
        property: "payload",
        msg: payload
      },
      retain: undefined
    })
  }

  return {
    init: init,
    stop: stop,
    setNodeStatus: setNodeStatus,
    setNodeContext: setNodeContext,
    receivedFromEngine: receivedFromEngine,
    sendToEngine: sendToEngine
  }
}

