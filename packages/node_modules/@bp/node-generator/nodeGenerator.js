//TODO: check field types: date, select, multiSelect
//TODO: add advanced validator to template and call it from all fields

module.exports = function () {

  const fs = require('fs');
  const fsExtra = require('fs-extra')
  const path = require('path');
  let html = fs.readFileSync(path.join(__dirname, 'inOut.html.template'), 'utf8');
  let js = fs.readFileSync(path.join(__dirname, 'inOut.js.template'), 'utf8');
  let packageJson = fs.readFileSync(path.join(__dirname, 'package.json.template'), 'utf8');


  class Node {
    /**
     * Creates a node with the given parameters
     * @param {string} name The name of the node. The name will be converted to title case and sanitized.
     * @param {string} category The category of the node
     * @param {number} [numInput=1] The number of input ports, can be 0 or 1 (default).
     * @param {string|string-of-a-function} [paletteLabel=titleCase(name)] The label of the node in the palette. Default is the title case of the name.
     * @param {string|string-of-a-function} [label=`function () {
     *                updateColor(this.eventType, this.id);
     *                return this.name || "${titleCase(name)}";
     *                }`] The label of the node. Default is a srting of a function that returns the name of the node and updates the color based on RWB.
     * @param {string|string-of-a-function} [labelStyle=''] The style of the label (e.g., node_label_italic). Default is an empty string.
     * @param {string} [icon='file.png'] The icon of the node, to be choosed from https://nodered.org/docs/creating-nodes/appearance#icon
     * @param {string} [help=''] The help text of the node. Default is an empty string.
     * @param {string} [style=''] The style of the node. Default is an empty string.
     * @param {string[]} outputLabels The labels for the output ports. The number of labels determines the number of output ports.
     * @param {Field[]} fields The fields of the node
     */
    constructor(name, category, params = {
      numInput: 1,
      outputLabels: [''],
      paletteLabel: null,
      label: null,
      labelStyle: '',
      icon: 'file.png',
      align: 'left',
      help: '',
      fields: [],
      css: '',
    }) {
      this.name = sanitizeTitleCase(name);
      this.color = '#87A980';
      this.category = category;
      this.numInput = params.numInput || 1;
      this.outputLabels = JSON.stringify(params.outputLabels || ['']);
      this.numOutput = (params.outputLabels || ['']).length;
      this.paletteLabel = params.paletteLabel || titleCase(name);
      this.label = params.label || `function () {
      updateColor(this.eventType, this.id);
      return this.name || "${titleCase(name)}";
    }`;
      this.labelStyle = params.labelStyle || '';
      this.icon = params.icon || 'file.png';
      this.align = params.align || 'left';
      this.help = params.help || '';
      this.fields = params.fields || [];
      this.sharedConfiguration = '<div class="form-row">\n' +
        '        <label for="node-input-name"><i class="fa fa-tag"></i> <span data-i18n="node-red:common.label.name"></span></label>\n' +
        '        <input type="text" id="node-input-name" data-i18n="[placeholder]node-red:common.label.name">\n' +
        '    </div>\n' +
        '    <div class="form-row">\n' +
        '        <label for="node-input-eventType"><i class="fa fa-tasks"></i></label>\n' +
        '        <select id="node-input-eventType">\n' +
        '            <option value="request">Request this event</option>\n' +
        '            <option value="waitFor">Wait for this event</option>\n' +
        '            <option value="block">Block this event</option>\n' +
        '        </select>\n' +
        '    </div>\n' +
        '    <div class="form-row" hidden="hidden">\n' +
        '        <label for="node-input-internalFields" style="width:35%"><i class="fa fa-tasks"></i> Internal fields</label>\n' +
        '        <input type="text" id="node-input-internalFields">\n' +
        '    </div>';
      this.configuration = this.fields.map(f => f.getDiv()).join("\n    ");
      this.defaults = `internalFields: { value: "${JSON.stringify(this.fields.map(f => f.getInternalField())).replace(/"/g, '\\"')}" },
      ${this.fields.map(f => f.getAttributes()).join("\n      ")}`;
      this.package = '\t\t\t"' + name + '": "' + name + '.js",';
      this.oneditprepare = "";
      if (this.fields.length > 0) {
        this.oneditprepare = this.fields.map(f => f.getOnEditPrepare()).join("\n      ");
        this.oneditprepare += `
      $(".sync-wd").hide();
      $("#node-input-eventType").on('change', function () {
        if (this.value === "request" && that.eventType !== "request") {${this.fields.map(f => `
          $("#node-input-${f.name}R").typedInput('type', $("#node-input-${f.name}Type").val());
          $("#node-input-${f.name}R").typedInput('value', $("#node-input-${f.name}").val());`).join("\n          ")}
          $(".sync-wd").hide();
          $(".sync-r").show();
        } else if (this.value !== "request" && that.eventType === "request") {${this.fields.map(f => `
          $("#node-input-${f.name}").typedInput('type', $("#node-input-${f.name}RType").val());
          $("#node-input-${f.name}").typedInput('value', $("#node-input-${f.name}R").val());
          $("#node-input-${f.name}R").typedInput('value', defaultTypeValue($("#node-input-${f.name}RType").val()));`).join("\n          ")}
          $(".sync-r").hide();
          $(".sync-wd").show();
        }
        that.eventType = this.value;
      });`
      }
      this.css = params.css || '';
    }

    toHTML() {
      let regex = /{{([a-zA-Z]+)}}/g
      let newHtml = html.replace(regex, (match, p1, offset, string) => this[p1])
      return newHtml;
    }

    toJS() {
      let regex = /{{([a-zA-Z]+)}}/g
      let newJs = js.replace(regex, (match, p1, offset, string) => this[p1])
      return newJs;
    }
  }

  function titleCase(str) {
    var splitStr = str.toLowerCase().split(/\s*[_ ]\s*/);
    for (var i = 0; i < splitStr.length; i++) {
      // You do not need to check if i is larger than splitStr length, as your for does that for you
      // Assign it back to the array
      splitStr[i] = splitStr[i].charAt(0).toUpperCase() + splitStr[i].substring(1);
    }
    // Directly return the joined string
    return splitStr.join(' ');
  }

  /**
   * Normalize camel-case.
   *
   * For example: `a-random node type` will normalise to `aRandomNodeType`
   *
   * @param  {String} name - the node type
   * @return {String} The normalised name
   */
  function sanitizeCamelCase(name) {
    let result = sanitizeTitleCase(name);
    result = result.charAt(0).toLowerCase() + result.slice(1);
    return result;
  }

  /**
   * Normalize camel-case.
   *
   * For example: `a-random node type` will normalise to `aRandomNodeType`
   *
   * @param  {String} name - the node type
   * @return {String} The normalised name
   */
  function sanitizeTitleCase(name) {
    let result = name.replace(/[^a-zA-Z0-9]/g, " ");
    result = result.trim();
    result = result.replace(/ +/g, " ");
    result = result.replace(/ ./g,
      function (s) {
        return s.charAt(1).toUpperCase();
      }
    );
    result = result.charAt(0).toUpperCase() + result.slice(1);
    return result;
  }

  function sanitizeDash(name) {
    let result = name.replace(/[^a-zA-Z0-9]/g, " ");
    result = result.trim();
    result = result.replace(/ +/g, " ");
    result = result.replace(/ /g, "-");
    return result.toLowerCase();
  }

  class Field {
    /**
     * Creates a Field with the given parameters
     * @param {string} label The label of the field
     * @param {string[]}[type=['string']] The possible types of the field. Types can be: str, num, bool, date, json, select, multiSelect.
     * If select and multiSelect are used, the array should be in length of 1 (i.e., contain only one of them).
     * If select and multiSelect are not used, the array should include 'msg', and 'jsonata'.
     * @param {string[]}[defaultValue=undefined] An array of default values for each corresponding type.
     * If undeifned, the default value for all types will be an empty string.
     * If the type is select or multiSelect, the default value must be an array with a single string of the default value.
     * @param {string[]}[options=] The options for a 'select' field, only used if the type is select
     * @param {boolean}[required=true] Whether the field is required or not
     */
    constructor(label, params = {
      types: ['str'], defaultValue: undefined, options: undefined, required: true
    }) {
      this.label = titleCase(label);
      this.name = sanitizeCamelCase(label);
      this.types = params.types || ['str'];
      this.types = Array.isArray(this.types) ? this.types : [this.types];
      this.types.push('msg');
      this.types.push('jsonata');
      this.defaultValue = params.defaultValue;
      if (typeof this.defaultValue !== 'undefined' && this.defaultValue.length !== this.types.length) {
        throw new Error('The length of the defaultValue array must be equal to the length of the types array.')
      }
      if (typeof this.defaultValue === 'undefined') {
        this.defaultValue = this.types.map(t => t === 'select' || t === 'multiSelect' ? 'select' : '');
      } else {
        this.defaultValue = defaultValue;
      }
      this.options = params.options;
      if (this.types.includes('select') || this.types.includes('multiSelect')) {
        if(!this.options || this.options.length === 0) {
          throw new Error('Options must be given of types select and multiSelect.')
        }
      }
      this.required = params.required || true;
    }

    getDiv() {
        return `<div class="form-row sync-wd">
        <label for="node-input-${this.name}">${this.label}:</label>
        <input type="hidden" id="node-input-${this.name}Type">
        <input style="width:70%" type="text" id="node-input-${this.name}" placeholder="1">
    </div>
    <div class="form-row sync-r">
        <label for="node-input-${this.name}R">${this.label}:</label>
        <input type="hidden" id="node-input-${this.name}RType">
        <input style="width:70%" type="text" id="node-input-${this.name}R" placeholder="1">
    </div>`
    }

    getOnEditPrepare() {
      let that = this;
      function part(R) {
        return `$("#node-input-${that.name}${R}").typedInput({
          default: '${that.defaultValue[0]}',
          typeField: '#node-input-${that.name}${R}Type',
          types: [${that.types.map(t => {
            if(t === 'select' || t === 'multiSelect') {
              return `{
                value: '${t}',
                options: [
                  { value: 'select', label: 'Select' },
                  ${that.options.map(o => `{ value: '${sanitizeCamelCase(o)}', label: '${o}' }`).join(',\n                  ')}
                ],
                ${t === 'multiSelect' ? 'multiple: "true"' : ''}
              }`
            } else {
              return `'${t}'`
            }
          }).join(', ')}]
        });`
      }
      return part('') + '\n          ' + part('R');
    }

    getInternalField() {
      return this.name;
    }

    getAttributes() {
      if (this.types[0] === 'select' || this.types[0] === 'multiSelect') {
        return `${this.name}R: { value: "${this.defaultValue[0]}", required: ${this.required}, validate: v => v !== "select" },
      ${this.name}: { value: "${this.defaultValue[0]}", required: ${this.required} },`
      } else {
        return `${this.name}: { value: "${this.defaultValue[0]}", required: false, validate: RED.validators.typedInput("${this.name}Type", false) },
      ${this.name}Type: { value: "${this.types[0]}" },
      ${this.name}R: { value: "${this.defaultValue[0]}", required: ${this.required}, validate: RED.validators.typedInput("${this.name}RType", false) },
      ${this.name}RType: { value: "${this.types[0]}" },`
      }
    }
  }

  function createNode(node) {
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', node.name + '.html'), node.toHTML());
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', node.name + '.js'), node.toJS());
  }

  function generatePackage(nodes) {
    let list = nodes.map(n => '\t\t\t"' + n.name + '": "' + n.name + '.js"').join(',\n')
    let newPackage = packageJson.replace(/{{nodes}}/g, list);
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', 'package.json'), newPackage);
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', 'generated.js'), 'module.exports = false\n');
  }

  function generateNodes(inOutNodes) {
    fsExtra.emptyDirSync(path.join(__dirname, '..', 'nodes', 'generated'))
    generatePackage(inOutNodes);

    for (let n of inOutNodes) {
      createNode(n);
    }
  }

  return {
    Node,
    Field,
    generateNodes: generateNodes
  }
}
