module.exports = function () {

  const fs = require('fs');
  const fsExtra = require('fs-extra')
  const path = require('path');
  let html = fs.readFileSync(path.join(__dirname, 'inOut.html.template'), 'utf8');
  let js = fs.readFileSync(path.join(__dirname, 'inOut.js.template'), 'utf8');
  let packageJson = fs.readFileSync(path.join(__dirname, 'package.json.template'), 'utf8');


  class Node {
    /**
     * Creates a node with the given parameters
     * @param {string} name The name of the node. The name will be converted to title case and sanitized.
     * @param {string} category The category of the node
     * @param {number} [numInput=1] The number of input ports, can be 0 or 1 (default).
     * @param {string|string-of-a-function} [paletteLabel=titleCase(name)] The label of the node in the palette. Default is the title case of the name.
     * @param {string|string-of-a-function} [label=`function () {
     *                updateColor(this.eventType, this.id);
     *                return this.name || "${titleCase(name)}";
     *                }`] The label of the node. Default is a srting of a function that returns the name of the node and updates the color based on RWB.
     * @param {string|string-of-a-function} [labelStyle=''] The style of the label (e.g., node_label_italic). Default is an empty string.
     * @param {string} [icon='file.png'] The icon of the node, to be choosed from https://nodered.org/docs/creating-nodes/appearance#icon
     * @param {string} [help=''] The help text of the node. Default is an empty string.
     * @param {string} [style=''] The style of the node. Default is an empty string.
     * @param {string[]} outputLabels The labels for the output ports. The number of labels determines the number of output ports.
     * @param {Field[]} fields The fields of the node
     */
    constructor(name, category, params = {
      numInput: 1,
      outputLabels: [''],
      paletteLabel: null,
      label: null,
      labelStyle: '',
      icon: 'file.png',
      align: 'left',
      help: '',
      fields: [],
      css: '',
      //rwb: "RWB"
    }) {


      this.name = sanitizeTitleCase(name);
      this.color = '#87A980';
      this.category = category;
      this.numInput = params.numInput || 1;
      this.outputLabels = JSON.stringify(params.outputLabels || ['']);
      this.numOutput = (params.outputLabels || ['']).length;
      this.paletteLabel = params.paletteLabel || titleCase(name);
      this.label = params.label || `function () {
      updateColor(this.eventType, this.id);
      return this.name || "${titleCase(name)}";
    }`;
      this.labelStyle = params.labelStyle || '';
      this.icon = params.icon || 'file.png';
      this.align = params.align || 'left';
      this.help = params.help || '';
      this.fields = params.fields || [];
      this.sharedConfiguration = '<div class="form-row">\n' +
        '        <label for="node-input-name"><i class="fa fa-tag"></i> <span data-i18n="node-red:common.label.name"></span></label>\n' +
        '        <input type="text" id="node-input-name" data-i18n="[placeholder]node-red:common.label.name">\n' +
        '    </div>\n' +
        '    <div class="form-row">\n' +
        '        <label for="node-input-eventType"><i class="fa fa-tasks"></i></label>\n' +
        '        <select id="node-input-eventType">\n' +

        ((!params.rwb || params.rwb.includes('R')) ?
          '            <option value="request">Request this event</option>\n' : '') +
        ((!params.rwb || params.rwb.includes('W')) ?
          '            <option value="waitFor">Wait for this event</option>\n' : '') +
        ((!params.rwb || params.rwb.includes('B')) ?
          '            <option value="block">Block this event</option>\n' : '') +
        '        </select>\n' +
        '    </div>\n' +
        '    <div class="form-row" hidden="hidden">\n' +
        '        <label for="node-input-internalFields" style="width:35%"><i class="fa fa-tasks"></i> Internal fields</label>\n' +
        '        <input type="text" id="node-input-internalFields">\n' +
        '    </div>';
      this.configuration = this.fields.map(f => f.getDiv()).join("\n    ");
      this.defaults = `internalFields: { value: "${JSON.stringify(this.fields.map(f => f.getInternalField())).replace(/"/g, '\\"')}" },
      ${this.fields.map(f => f.getAttributes()).join("\n      ")}`;
      this.package = '\t\t\t"' + name + '": "' + name + '.js",';
      this.oneditprepare = "";
      if (this.fields.length > 0) {
        this.oneditprepare = `$(".sync-wd").hide();
      $("#node-input-eventType").on('change', function () {
        if (this.value === "request" && that.eventType !== "request") {${this.fields.map(f => `
          $("#node-input-${f.name}R").typedInput('type', $("#node-input-${f.name}Type").val());
          $("#node-input-${f.name}R").typedInput('value', $("#node-input-${f.name}").val());`).join("\n          ")}
          $(".sync-wd").hide();
          $(".sync-r").show();
        } else if (this.value !== "request" && that.eventType === "request") {${this.fields.map(f => `
          $("#node-input-${f.name}").typedInput('type', $("#node-input-${f.name}RType").val());
          $("#node-input-${f.name}").typedInput('value', $("#node-input-${f.name}R").val());
          $("#node-input-${f.name}R").typedInput('value', defaultTypeValue($("#node-input-${f.name}RType").val()));`).join("\n          ")}
          $(".sync-r").hide();
          $(".sync-wd").show();
        }
        that.eventType = this.value;
      });
      `
        this.oneditprepare += this.fields.map(f => f.getOnEditPrepare()).join("\n      ");
      }
      this.css = params.css || '';
    }

    toHTML() {
      let regex = /{{([a-zA-Z]+)}}/g
      let newHtml = html.replace(regex, (match, p1, offset, string) => this[p1])
      return newHtml;
    }

    toJS() {
      let regex = /{{([a-zA-Z]+)}}/g
      let newJs = js.replace(regex, (match, p1, offset, string) => this[p1])
      return newJs;
    }
  }

  function titleCase(str) {
    var splitStr = str.toLowerCase().split(/\s*[_ ]\s*/);
    for (var i = 0; i < splitStr.length; i++) {
      // You do not need to check if i is larger than splitStr length, as your for does that for you
      // Assign it back to the array
      splitStr[i] = splitStr[i].charAt(0).toUpperCase() + splitStr[i].substring(1);
    }
    // Directly return the joined string
    return splitStr.join(' ');
  }

  /**
   * Normalize camel-case.
   *
   * For example: `a-random node type` will normalise to `aRandomNodeType`
   *
   * @param  {String} name - the node type
   * @return {String} The normalised name
   */
  function sanitizeCamelCase(name) {
    let result = sanitizeTitleCase(name);
    result = result.charAt(0).toLowerCase() + result.slice(1);
    return result;
  }

  /**
   * Normalize camel-case.
   *
   * For example: `a-random node type` will normalise to `aRandomNodeType`
   *
   * @param  {String} name - the node type
   * @return {String} The normalised name
   */
  function sanitizeTitleCase(name) {
    let result = name.replace(/[^a-zA-Z0-9]/g, " ");
    result = result.trim();
    result = result.replace(/ +/g, " ");
    result = result.replace(/ ./g,
      function (s) {
        return s.charAt(1).toUpperCase();
      }
    );
    result = result.charAt(0).toUpperCase() + result.slice(1);
    return result;
  }

  function sanitizeDash(name) {
    let result = name.replace(/[^a-zA-Z0-9]/g, " ");
    result = result.trim();
    result = result.replace(/ +/g, " ");
    result = result.replace(/ /g, "-");
    return result.toLowerCase();
  }

  class Field {
    /**
     * Creates a Field with the given parameters
     * @param {string} label The label of the field
     * @param {string[]}[type=['string', 'msg', 'jsonata']] The possible types of the field. Types can be: str, num, bool, date, json, select, multiSelect, 'msg', and 'jsonata'.
     * If the array does not include 'msg' or 'jsonata', they are added to the end.
     * @param {string[]}[defaultValue=undefined] An array of default values for each corresponding type.
     * If undeifned, the default value for all types will be an empty string.
     * If the type is select or multiSelect, the default value must be an array with a single string of the default value.
     * @param {string[]}[options=] The options for 'select' and 'multiSelect' fields. Only used when these types are used.
     * @param {boolean}[required=true] Whether the field is required or not
     */
    constructor(label, params = {
      types: ['str'], defaultValue: undefined, options: undefined, required: true, hidden: false
    }) {
      this.label = titleCase(label);
      this.name = sanitizeCamelCase(label);
      this.types = params.types || ['str', 'msg', 'jsonata'];
      this.types = Array.isArray(this.types) ? this.types : [this.types];
      if (!this.types.includes('msg'))
        this.types.push('msg');
      if (!this.types.includes('jsonata'))
        this.types.push('jsonata');
      this.defaultValue = params.defaultValue;
      if (typeof this.defaultValue !== 'undefined' && this.defaultValue.length !== this.types.length) {
        throw new Error(`In label ${label}, the length of the defaultValue array must be equal to the length of the types array ${this.defaultValue.length} !== ${this.types.length}.
        The types are ${this.types} and the default values are ${this.defaultValue}`);
      }
      if (typeof this.defaultValue === 'undefined') {
        this.defaultValue = this.types.map(t => t === 'select' || t === 'multiSelect' ? 'select' : '');
      } else {
        this.defaultValue = params.defaultValue;
      }
      this.options = params.options;
      if (this.types.includes('select') || this.types.includes('multiSelect')) {
        if (!this.options || this.options.length === 0) {
          throw new Error('Options must be given of types select and multiSelect.')
        }
      }
      this.required = params.required || true;
      this.hidden = params.hidden || false;

    }

    getDiv() {
      return `<div class="form-row sync-wd" >
        <div ${this.hidden ? 'hidden' : ''}>
          <label for="node-input-${this.name}">${this.label}:</label>
          <input type="hidden" id="node-input-${this.name}Type">
          <input style="width:70%" type="text" id="node-input-${this.name}" placeholder="1">
        </div>
    </div>
    <div class="form-row sync-r">
      <div ${this.hidden ? 'hidden' : ''}>
        <label for="node-input-${this.name}R">${this.label}:</label>
        <input type="hidden" id="node-input-${this.name}RType">
        <input style="width:70%" type="text" id="node-input-${this.name}R" placeholder="1">
      </div>

    </div>`
    }

    getOnEditPrepare() {
      let that = this;

      function part(R) {
        return `$("#node-input-${that.name}${R}").typedInput({
          default: '${that.defaultValue[0]}',
          typeField: '#node-input-${that.name}${R}Type',
          types: [${that.types.map(t => {
          if (t === 'select' || t === 'multiSelect') {
            return `{
                value: '${t}',
                options: [
                  ${t === 'select' ? `{ value: 'select', label: 'Select' },` : ''}
                  ${that.options.map(o => `{ value: '${sanitizeCamelCase(o)}', label: '${o}' }`).join(',\n                  ')}
                ],
                ${t === 'multiSelect' ? 'multiple: "true"' : ''}
              }`
          } else {
            return `'${t}'`
          }
        }).join(', ')}]
        });`
      }

      return part('') + '\n          ' + part('R');
    }

    getInternalField() {
      return this.name;
    }

    getAttributes() {
      return `${this.name}Type: { value: "${this.types[0]}" },
      ${this.name}: { value: "${this.defaultValue[0]}", required: false, validate: v => bpValidator('${this.name}', '', v) },
      ${this.name}RType: { value: "${this.types[0]}" },
      ${this.name}R: { value: "${this.defaultValue[0]}", required: ${this.required}, validate: v => bpValidator('${this.name}', 'R', v) },`
    }
  }

  function createNode(node) {
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', node.name + '.html'), node.toHTML());
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', node.name + '.js'), node.toJS());
  }

  function generatePackage(nodes) {
    let list = nodes.map(n => '\t\t\t"' + n.name + '": "' + n.name + '.js"').join(',\n')
    let newPackage = packageJson.replace(/{{nodes}}/g, list);
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', 'package.json'), newPackage);
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', 'generated.js'), 'module.exports = false\n');
  }

  function generateNodes(inOutNodes) {
    fsExtra.emptyDirSync(path.join(__dirname, '..', 'nodes', 'generated'))
    generatePackage(inOutNodes);

    for (let n of inOutNodes) {
      createNode(n);
    }
  }

  return {
    Node,
    Field,
    generateNodes: generateNodes
  }
}
