//TODO: fields may be required in request mode, but not in waitFor/block mode
//TODO: check execution of the node in the different types

module.exports = function () {

  const fs = require('fs');
  const fsExtra = require('fs-extra')
  const path = require('path');
  let html = fs.readFileSync(path.join(__dirname, 'inOut.html.template'), 'utf8');
  let js = fs.readFileSync(path.join(__dirname, 'inOut.js.template'), 'utf8');
  let packageJson = fs.readFileSync(path.join(__dirname, 'package.json.template'), 'utf8');

  /**
   * Creates a node with the given parameters
   * @param {string} name The name of the node. The name will be converted to title case and sanitized. It will be used for all [label types](https://nodered.org/docs/creating-nodes/appearance#labels)
   * @param {string} category The category of the node
   * @param {Field[]} fields The fields of the node
   * @param {string} [icon='file.png'] The icon of the node, to be choosed from https://nodered.org/docs/creating-nodes/appearance#icon
   * @param {string} [color='#a6bbcf'] The [background color](https://nodered.org/docs/creating-nodes/appearance#background-colour) of the node. Default is a light blue (#a6bbcf).
   * @param {string} [help=''] The help text of the node. Default is an empty string.
   * @param {string} [style=''] The style of the node. Default is an empty string.
   * @param {number} [numInput=1] The number of input ports, can be 0 or 1 (default).
   * @param {string[]} outputLabels The labels for the output ports. The number of labels determines the number of output ports.
   * @returns {InOutNode} The created node
   */
  function InOutNode(
    name,
    category,
    fields = [],
    icon = 'file.png',
    color = '#a6bbcf',
    help = '',
    style = '',
    numInput = 1,
    outputLabels = ['']) {

    let node = {
      name: sanitizeTitleCase(name),
      category: category,
      sanitizedName: sanitizeTitleCase(name),
      help: help,
      color: color,
      icon: icon,
      label: 'function () {\n' +
        '      updateColor(this.eventType, this.id);\n' +
        '      return this.name || "' + titleCase(name) + '";\n' +
        '    }',
      paletteLabel: titleCase(name),
      numInput: numInput,
      numOutput: outputLabels.length,
      outputLabels: '[' + outputLabels + ']',
      style: style,
      sharedConfiguration: '<div class="form-row">\n' +
        '        <label for="node-input-name"><i class="fa fa-tag"></i> <span data-i18n="node-red:common.label.name"></span></label>\n' +
        '        <input type="text" id="node-input-name" data-i18n="[placeholder]node-red:common.label.name">\n' +
        '    </div>\n' +
        '    <div class="form-row">\n' +
        '        <label for="node-input-eventType"><i class="fa fa-tasks"></i></label>\n' +
        '        <select id="node-input-eventType">\n' +
        '            <option value="request">Request this event</option>\n' +
        '            <option value="waitFor">Wait for this event</option>\n' +
        '            <option value="block">Block this event</option>\n' +
        '        </select>\n' +
        '    </div>\n' +
        '    <div class="form-row" hidden="hidden">\n' +
        '        <label for="node-input-internalFields" style="width:35%"><i class="fa fa-tasks"></i> Internal fields</label>\n' +
        '        <input type="text" id="node-input-internalFields">\n' +
        '    </div>',
      configuration: fields.map(f => f.getDiv()).join("\n    "),
      defaults: `internalFields: { value: "${JSON.stringify(fields.map(f => f.getInternalField())).replace(/"/g, '\\"')}" },
      ${fields.map(f => f.getAttributes()).join("\n      ")}`,
      package: '\t\t\t"' + name + '": "' + name + '.js",',
      oneditprepare: fields.map(f => f.getJS()).join("\n      ")
    }
    return node
  }

  function titleCase(str) {
    var splitStr = str.toLowerCase().split(/\s*[_ ]\s*/);
    for (var i = 0; i < splitStr.length; i++) {
      // You do not need to check if i is larger than splitStr length, as your for does that for you
      // Assign it back to the array
      splitStr[i] = splitStr[i].charAt(0).toUpperCase() + splitStr[i].substring(1);
    }
    // Directly return the joined string
    return splitStr.join(' ');
  }

  /**
   * Normalize camel-case.
   *
   * For example: `a-random node type` will normalise to `aRandomNodeType`
   *
   * @param  {String} name - the node type
   * @return {String} The normalised name
   */
  function sanitizeCamelCase(name) {
    let result = sanitizeTitleCase(name);
    result = result.charAt(0).toLowerCase() + result.slice(1);
    return result;
  }

  /**
   * Normalize camel-case.
   *
   * For example: `a-random node type` will normalise to `aRandomNodeType`
   *
   * @param  {String} name - the node type
   * @return {String} The normalised name
   */
  function sanitizeTitleCase(name) {
    let result = name.replace(/[^a-zA-Z0-9]/g, " ");
    result = result.trim();
    result = result.replace(/ +/g, " ");
    result = result.replace(/ ./g,
      function (s) {
        return s.charAt(1).toUpperCase();
      }
    );
    result = result.charAt(0).toUpperCase() + result.slice(1);
    return result;
  }

  function sanitizeDash(name) {
    let result = name.replace(/[^a-zA-Z0-9]/g, " ");
    result = result.trim();
    result = result.replace(/ +/g, " ");
    result = result.replace(/ /g, "-");
    return result.toLowerCase();
  }

  class Field {
    /**
     * Creates a Field with the given parameters
     * @param {string} label The label of the field
     * @param {string[]}[type=['string', 'msg', 'jsonata']] The possible types of the field. Types can be: str, num, bool, date, json, jsonata, msg, select, multiSelect.
     * If select and multiSelect are used, the array should be in length of 1 (i.e., contain only one of them).
     * If select and multiSelect are not used, the array should include 'msg', and 'jsonata'.
     * @param {string[]}[defaultValue=undefined] An array of default values for each corresponding type.
     * If undeifned, the default value for all types will be an empty string.
     * If the type is select or multiSelect, the default value must be an array with a single string of the default value.
     * @param {string[]}[options=] The options for a 'select' field, only used if the type is select
     * @param {boolean} [required=false] If the field is required
     */
    constructor(label, types = ['str', 'msg', 'jsonata'], defaultValue = undefined, options = undefined, required = false) {
      this.label = titleCase(label);
      this.name = sanitizeCamelCase(label);
      this.types = Array.isArray(types) ? types : [types];
      // verify that if types contains select or multiSelect, it is the only type
      if ((this.types.includes('select') || this.types.includes('multiSelect')) && this.types.length > 1) {
        throw new Error('The types select and multiSelect can only be used alone.')
      }
      if (typeof defaultValue !== 'undefined' && defaultValue.length !== this.types.length) {
        throw new Error('The length of the defaultValue array must be equal to the length of the types array.')
      }
      if (typeof defaultValue === 'undefined') {
        this.defaultValue = this.types.map(t => '');
      } else {
        this.defaultValue = defaultValue;
      }
      this.options = options;
      this.required = required;
    }

    getDiv() {
      if (this.types[0] === 'select' || this.types[0] === 'multiSelect') {
        return `<label for="node-input-${this.name}">${this.label}:</label>
                <select id="node-input-${this.name}">
                <option value="select">Select</option>
                ${this.options.map(option => `        <option value="${sanitizeDash(option)}">${option}</option>`).join('\n')}        
                </select>\n`;
      } else {
        return `<div class="form-row">
        <label for="node-input-${this.name}">${this.label}:</label>
        <input type="hidden" id="node-input-${this.name}Type">
        <input style="width:70%" type="text" id="node-input-${this.name}" placeholder="1">
        </div>`
      }
    }

    getJS() {
      if (this.types[0] === 'select' || this.types[0] === 'multiSelect') {
      } else {
        return `$("#node-input-${this.name}").typedInput({
        default: 'str',
        typeField: $("#node-input-${this.name}Type"),
        types: [${this.types.map(t => `'${t}'`).join(',')}]
      });`
      }
    }

    getInternalField() {
      return { name: this.name, type: this.types[0], value: this.defaultValue[0] }
    }

    getAttributes() {
      if (this.types[0] === 'select' || this.types[0] === 'multiSelect') {
        return `${this.name}: { value: "${this.defaultValue[0]}", required: ${this.required} },`
      } else {
        return `${this.name}: { value: "${this.defaultValue[0]}", required: ${this.required}, validate: RED.validators.typedInput("${this.name}Type", false) },
      ${this.name}Type: { value: "${this.types[0]}" },`
      }
    }
  }

  function createNode(node) {
    let regex = /{{([a-zA-Z]+)}}/g

    let newHtml = html.replace(regex, (match, p1, offset, string) => node[p1])
    let newJs = js.replace(regex, (match, p1, offset, string) => node[p1])

    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', node.sanitizedName + '.html'), newHtml);
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', node.sanitizedName + '.js'), newJs);
  }

  function generatePackage(nodes) {
    let list = nodes.map(n => '\t\t\t"' + n.name + '": "' + n.sanitizedName + '.js"').join(',\n')
    let newPackage = packageJson.replace(/{{nodes}}/g, list);
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', 'package.json'), newPackage);
    fs.writeFileSync(path.join(__dirname, '..', 'nodes', 'generated', 'generated.js'), 'module.exports = false\n');
  }

  function generateNodes(inOutNodes) {
    fsExtra.emptyDirSync(path.join(__dirname, '..', 'nodes', 'generated'))
    generatePackage(inOutNodes);

    for (let n of inOutNodes) {
      createNode(n);
    }
  }

  return {
    InOutNode,
    Field,
    generateNodes: generateNodes
  }
}