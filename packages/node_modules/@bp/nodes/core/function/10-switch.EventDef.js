function switchNode(n, msg) {
  const operators = {
    'eq': function (a, b) {
      return a == b;
    },
    'neq': function (a, b) {
      return a != b;
    },
    'lt': function (a, b) {
      return a < b;
    },
    'lte': function (a, b) {
      return a <= b;
    },
    'gt': function (a, b) {
      return a > b;
    },
    'gte': function (a, b) {
      return a >= b;
    },
    'btwn': function (a, b, c) {
      return (a >= b && a <= c) || (a <= b && a >= c);
    },
    'cont': function (a, b) {
      return (a + "").indexOf(b) != -1;
    },
    'regex': function (a, b, c, d) {
      return (a + "").match(new RegExp(b, d ? 'i' : ''));
    },
    'true': function (a) {
      return a === true;
    },
    'false': function (a) {
      return a === false;
    },
    'null': function (a) {
      return (typeof a == "undefined" || a === null);
    },
    'nnull': function (a) {
      return (typeof a != "undefined" && a !== null);
    },
    'empty': function (a) {
      if (typeof a === 'string' || Array.isArray(a) || Buffer.isBuffer(a)) {
        return a.length === 0;
      } else if (typeof a === 'object' && a !== null) {
        return Object.keys(a).length === 0;
      }
      return false;
    },
    'nempty': function (a) {
      if (typeof a === 'string' || Array.isArray(a) || Buffer.isBuffer(a)) {
        return a.length !== 0;
      } else if (typeof a === 'object' && a !== null) {
        return Object.keys(a).length !== 0;
      }
      return false;
    },
    'istype': function (a, b) {
      if (b === "array") {
        return Array.isArray(a);
      } else if (b === "buffer") {
        return Buffer.isBuffer(a);
      } else if (b === "json") {
        try {
          JSON.parse(a);
          return true;
        }   // or maybe ??? a !== null; }
        catch (e) {
          return false;
        }
      } else if (b === "null") {
        return a === null;
      } else {
        return typeof a === b && !Array.isArray(a) && !Buffer.isBuffer(a) && a !== null;
      }
    },
    'else': function (a) {
      return a === true;
    }
  };

  function getV1(node, msg, rule) {
    if (rule.vt === 'json') {
      return "json"; // TODO: ?! invalid case
    } else if (rule.vt === 'null') {
      return "null";
    } else {
      return RED.util.evaluateNodeProperty(rule.v, rule.vt, node, msg);
    }
  }

  function getV2(node, msg, rule) {
    let v2 = rule.v2;
    if (typeof v2 !== 'undefined') {
      return RED.util.evaluateNodeProperty(rule.v2, rule.v2t, node, msg);
    } else {
      return v2;
    }
  }

  function applyRule(node, msg, property, state) {
    let rule = node.rules[state.currentRule];
    let v1 = getV1(node, msg, rule);
    let v2 = getV2(node, msg, rule);
    if (rule.t == "else") {
      property = state.elseflag;
      state.elseflag = true;
    }
    if (operators[rule.t](property, v1, v2, rule.case, msg.parts)) {
      state.onward.push(msg);
      state.elseflag = false;
      if (node.checkall == "false") {
        return false;
      }
    } else {
      state.onward.push(null);
    }
    return state.currentRule < node.rules.length - 1;
  }

  function applyRules(node, msg, property, state) {
    if (!state) {
      state = {
        currentRule: 0,
        elseflag: true,
        onward: [],
        hasParts: false
      }
    }

    while (applyRule(node, msg, property, state)) {
      state.currentRule++;
    }
    return state.onward;
  }

  let node = {};
  node.rules = n.rules || [];
  node.property = n.property;
  node.propertyType = n.propertyType || "msg";
  node.checkall = n.checkall || "true";

  // bp.log.info("n={0}, node={1}, msg={2}", n,node,msg)

  for (let i = 0; i < node.rules.length; i += 1) {
    let rule = node.rules[i];
    if (!rule.vt) {
      if (!isNaN(Number(rule.v))) {
        rule.vt = 'num';
      } else {
        rule.vt = 'str';
      }
    }
    if (rule.vt === 'num') {
      if (!isNaN(Number(rule.v))) {
        rule.v = Number(rule.v);
      }
    }
    if (typeof rule.v2 !== 'undefined') {
      if (!rule.v2t) {
        if (!isNaN(Number(rule.v2))) {
          rule.v2t = 'num';
        } else {
          rule.v2t = 'str';
        }
      }
      if (rule.v2t === 'num') {
        rule.v2 = Number(rule.v2);
      }
    }
  }

  let property = RED.util.evaluateNodeProperty(node.property, node.propertyType, node, msg);
  return applyRules(node, msg, property)
}
